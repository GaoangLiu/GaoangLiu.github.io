---
layout:     post
title:      Message Queue
date:       2021-07-10
tags: [message queue, nsq]
categories: 
- algorithm
---


消息中间件 (Message oriented middleware) 是在分布式系统的一个子系统，关注于消息的发送和接收，也称**消息队列**(Message Queue, MQ)，利用高效可靠的消息传递机制进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息队列模型，可以在分布式环境下扩展进程的通信。

当前业界比较流行的开源消息中间件包括：ActiveMQ(Apache)、RabbitMQ(Pivotal)、RocketMQ(阿里巴巴)、Kafka(LinkedIn), ZeroMQ(iMatix) 等，其中应用最为广泛的有 RabbitMQ、RocketMQ、Kafka 这三款。


# 为什么需要消息中间件❓
考虑一个电商交易的场景，用户下单之后调用库存系统减库存，然后需要调用物流系统进行发货，如果交易、库存、物流是属于一个系统的，那么就是接口调用。但是随着系统的发展，各个模块越来越庞大、业务逻辑越来越复杂，必然是要做服务化和业务拆分的。这个时候就需要考虑这些系统之间如何交互，一种可行方案就是**RPC（Remote Procedure Call）**。系统继续发展，可能一笔交易后续需要调用几十个接口来执行业务，比如还有风控系统、短信服务等等。这个时候就需要消息中间件来解决问题了。

以购物系统为例，用户的一个下单操作可能触发一系列任务，比如提醒卖家处理新订单、更新用户画像、给用户推荐其他相关产品等等。这些任务进入系统中并以**串行方式运行**，这样就至少存在以下问题:
1. **过度耦合**：如果后面创建订单时，需要触发新的动作，那就得更改原有代码。
2. **缺少缓冲**：如果创建订单时，会员系统恰好处于非常忙碌或者宕机的状态，那这时订单提醒可能就会失败，我们需要一个地方，来暂时存放无法被消费的消息。

<img src='https://i.loli.net/2021/07/04/tY8RVnW246ITXDi.png' width='40%'>

因此，我们需要一个消息中间件，来实现解耦和缓冲的功能。

# 特点
消息中间件主要解决**分布式系统之间消息的传递，同时为分布式系统中其他子系统提供了伸缩性和扩展性**。为系统提供：
1. **低耦合**，不管是程序还是模块之间，使用消息中间件进行间接通信。
2. **异步通信能力**，使得子系统之间得以充分执行自己的逻辑而无需等待。
3. **缓冲能力**，消息中间件像是一个巨大的蓄水池，将高峰期大量的请求存储下来慢慢交给后台进行处理，对于秒杀业务来说尤为重要。


作为一个消息中间件，还需要满足：
1. **no SPOF**: SPOF = Single Point of Failure，无单点故障
2. **可拓展性强**：当一台服务器不够用时，你是否支持方便的横向扩展？nsq的扩展非常简单，默认一个生产者配置一个nsq，如果你需要俩，那就配置两个nsq地址即可
3. **可靠性强**：这一点，nsq 并不具备，默认情况下，消息是保存到内存的，一旦系统崩溃了，消息就没了。就算消息持久化到磁盘了，也只是做了一次备份，不像Kafka的partition机制，可以做多次备份
4. **性能好**：

# 组成 
- Broker，消息服务器，作为server提供消息核心服务
- Producer，消息生产者，业务的发起方，负责生产消息传输给 broker
- Consumer，消息消费者，业务的处理方，负责从broker获取消息并进行业务逻辑处理
- Topic，主题，发布订阅模式下的消息统一汇集地，不同生产者向topic发送消息，由MQ服务器分发到不同的订阅者，实现消息的广播
- Queue，队列，PTP 模式下，特定生产者向特定 queue 发送消息，消费者订阅特定的 queue 完成指定消息的接收
- Message，消息体，根据不同通信协议定义的固定格式进行编码的数据包，来封装业务数据，实现消息的传输

## 模式分类
1. 点对点，使用queue作为通信载体
    - 消息生产者生产消息发送到queue中，然后消息消费者从queue中取出并且消费消息
    - 消息被消费以后，queue中不再存储，所以消息消费者不可能消费到已经被消费的消息
    - Queue支持存在多个消费者，但是对一个消息而言，只会有一个消费者可以消费

2. 发布/订阅：使用topic作为通信载体 
    - 消息生产者（发布）将消息发布到topic中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到topic的消息会被所有订阅者消费
    - queue实现了负载均衡，将producer生产的消息发送到消息队列中，由多个消费者消费。但一个消息只能被一个消费者接受，当没有消费者可用时，这个消息会被保存直到有一个可用的消费者
    - topic实现了发布和订阅，当你发布一个消息，所有订阅这个topic的服务都能得到这个消息，所以从1到N个订阅者都能得到一个消息的拷贝



# 参考 
- [NSQ vs Kafka](https://zhuanlan.zhihu.com/p/46421050)
- [消息中间件知识](https://www.cnblogs.com/insane-Mr-Li/p/10684536.html)

