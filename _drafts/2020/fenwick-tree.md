---
layout:     post
title:      Fenwick Tree
date:       2020-04-13
tags: [algorithm, fenwick tree, bit]
categories: 
- algorithm
---

Fenwick tree, also called Binary Index Tree (BIT), is a data structure that can efficiently ($$O(log n)$$ time) update elements and calculate prefix sums in a table of numbers.

This structure was proposed by Boris Ryabko in 1989 [http://boris.ryabko.net/ryabko1992.pdf]  It has subsequently became known under the name Fenwick tree after Peter Fenwick who described this structure in his 1994 paper *A new data structure for cumulative frequency tables*.

# Why BIT ?
Consider the following problem, given an array $$a = [1,3,5,2,8,6,5]$$, we want to:

1. Get the sum of the first $$i: i \le a.size()$$ elements
2. Update the value of a specified element

There are two straightforward solutions: 

1. Run a loop from 0 to $$i-1$$ element to calculate the sum, time $$O(n)$$; update a value by simply running $$a[i]\ += val$$, time $$O(1)$$; 
2. Store sum of the first $$i$$-th element into an extra array. Get the sum of a given range can be done in $$O(1)$$, but update a value and re-calculate the sum takes $$O(n)$$ 

Both solutions run in $$O(n)$$ time, which is not bad, but far from satisfiable. 
And here comes BIT, performing both update and query operations in $$O(log n)$$ time without consuming much memory.

# How it works ?

The idea is based on the fact that **all positive integers can be represented as the sum of powers of 2**. E.g., 13 = 8(2^3) + 4(2^2) + 1(2^0). Each node $$ n $$ of BIT would store the sum of previous $$ k $$ elements, where $$k$$ is the number generated by extracting the least-significant bit from $$n$$, e.g., if $$n=4$$ with binary representation as 0b100, then $$k = 4$$, and if $$n == 6$$ with representation as 0b110, then $$k=2$$. 

1. Assume the size of array is $$n$$, we will need extra $$(n+1)$$-sized array, initiated with zeros and written as $$T_{bit}$$;
2. Make sure for each $$i, T_{bit}[i] = \text{sum}(a[p(i) .. i))$$ (exclusive on the right side), where $$p(i) = i - (i \& (-i))$$ is the parent node index of $$i$$. That is $$T_{bit}[i]$$ stores the sum of the elements from its parent (inclusive) to itself (exclusive). 
    * For example, when $$i = 4, p(i) = 0$$, then $$T_{bit}[4] = a[0]+a[1]+a[2]+a[3]$$. 
    * For another example, when $$i = 7, p(i) = 6$$, then $$T_{bit}[7] = a[6]$$. 

> The magic formula $$i - (i \& -i)$$ is to get the parent node $$j \leq i $$, a number generated by clearing the least-significant bit of $$i$$. 
> For example, if $$ i = 9 $$, then i == b1001, -i = b1111...110001, therefore $$i \& (-i) = 1$$, its parent node is 9-1=8. 
> If $$ i == 12$$, then i = b1100, -i = b111...1110100, thus $$i \& (-i) = 4$$, its parent node is 8.

Step 2 actually relies on the `add_value(T, i, val)` procedure, which:

1.  Adds the `val` to `T(i)`
2. Transmits the change to all even numbered node $$j$$ such that: 
    1. $$ j > i $$,
    2. $$ j $$ can be generated by recursively adding the least-significant bit (of $$i$$) to $$i$$. For example, if i = 0b11 (3), then the next i is 0b11 + 0b1 = 0b100 (4), and the next i is 0b100 + 0b100 = 0b1000 (8), and so on.


### View of binary indexed tree.

<img src="http://git.io/JUZE7" width="500px">


# Implementation (Python3)

```python
class FenwickTree:
    def __init__(self, arr):
        ''' Initialize with arr. 
        - self.tree[0] holds 0
        - self.tree[1] holds arr[0], 
        - self.tree[2] holds sum(arr[0], arr[1])
        - self.tree[3] holds sum(arr[2])
        - ...
        - self.tree[8] holds sum(arr[0], arr[1], ..., arr[7])
        '''
        self.tree = [0] * (len(arr) + 1)
        for i, v in enumerate(arr, 1):
            self.add_value(i, v)
        print(self.tree)

    def prefix_sum(self, i):
        '''Get sum of the first i numbers. 
        E.g., i = 3, n_sum = a[0] + a[1] + a[2]
        '''
        n_sum = 0
        while i > 0:
            n_sum += self.tree[i]
            i -= (i & (-i))
        return n_sum

    def add_value(self, i, val):
        ''' Add value val to node i (start from 1), and transmite the 
        changes to all even numbered nodes j satisfying:
        1. j > i, 
        2. j can be generated by (recursively) adding the last bit (of i) to i
            E.g., if i == 0b1011 (11), then i1 = 0b1100 (12), i2 = 0b1100 + 0b100 = 
            0b10000 (16) etc 
        '''
        while i < len(self.tree):
            self.tree[i] += val
            i += (i & (-i))
```



# References 
* [Fenwick Tree - Wikipedia](https://en.wikipedia.org/wiki/Fenwick_tree)
* [BIT - geeksforgeeks](https://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/)